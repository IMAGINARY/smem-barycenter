{"mappings":"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","sources":["node_modules/document-ready/index.js","src/ts/mathHelpers.ts","src/ts/barycenter.ts","src/ts/modeDraw-old.ts","src/ts/main.ts"],"sourcesContent":["'use strict'\n\nmodule.exports = ready\n\nfunction ready (callback) {\n  if (typeof document === 'undefined') {\n    throw new Error('document-ready only runs in the browser')\n  }\n  var state = document.readyState\n  if (state === 'complete' || state === 'interactive') {\n    return setTimeout(callback, 0)\n  }\n\n  document.addEventListener('DOMContentLoaded', function onLoad () {\n    callback()\n  })\n}\n","interface Point {\n  x: number;\n  y: number;\n}\n\nconst distSq = (ptA: Point, ptB: Point): number =>\n  (ptA.x - ptB.x) * (ptA.x - ptB.x) + (ptA.y - ptB.y) * (ptA.y - ptB.y);\n\nconst dist = (ptA: Point, ptB: Point): number => Math.sqrt(distSq(ptA, ptB));\n\n// Linear interpolation between x and y.\nconst lerp = (x: number, y: number, t: number) => (1 - t) * x + t * y;\n\nconst inverseLerp = (x: number, y: number, p: number) => {\n  if (Math.abs(y - x) !== 0) {\n    return Math.min(1, Math.max(0, Math.abs(p - x) / Math.abs(y - x)));\n  } else return 0;\n};\n\nconst slerp = (u: Point, v: Point, t: number) => {\n  const angle = Math.acos(u.x * v.x + u.y * v.y);\n\n  if (angle < 0.1) {\n    return u;\n  } else {\n    return {\n      x:\n        (Math.sin((1 - t) * angle) * u.x + Math.sin(t * angle) * v.x) /\n        Math.sin(angle),\n      y:\n        (Math.sin((1 - t) * angle) * u.y + Math.sin(t * angle) * v.y) /\n        Math.sin(angle),\n    };\n  }\n};\n\n// Clamps x between the values a and b.\nconst clamp = (x: number, a: number, b: number) =>\n  a <= b ? Math.min(Math.max(x, a), b) : Math.min(Math.max(x, b), a);\n\nexport { Point, lerp, inverseLerp, slerp, distSq, dist, clamp };\n","import { Layer, layerSetup } from './layer';\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction barycenterByBorder(P: Point[]): Point {\n  const N = P.length;\n  let SX = 0;\n  let SY = 0;\n  let SA = 0;\n  for (let i = 0; i < N; i++) {\n    SX +=\n      (P[i].x + P[(i + 1) % N].x) *\n      (P[i].x * P[(i + 1) % N].y - P[(i + 1) % N].x * P[i].y);\n    SY +=\n      (P[i].y + P[(i + 1) % N].y) *\n      (P[i].x * P[(i + 1) % N].y - P[(i + 1) % N].x * P[i].y);\n    SA += P[i].x * P[(i + 1) % N].y - P[(i + 1) % N].x * P[i].y;\n  }\n  const A = (1 / 2) * SA;\n  const Cx = (1 / (6 * A)) * SX;\n  const Cy = (1 / (6 * A)) * SY;\n\n  //   console.log(`barycenter: (${Cx},${Cy})`);\n  //   console.log(`area: ${A}`);\n  return { x: Cx, y: Cy };\n}\n\nfunction barycenterBySurface(ctx: CanvasRenderingContext2D): {\n  center: Point;\n  area: number;\n} {\n  //context: CanvasRenderingContext2D\n  const w = ctx.canvas.width;\n  const h = ctx.canvas.height;\n  const imgArray = ctx.getImageData(0, 0, w, h).data;\n\n  let SX = 0;\n  let SY = 0;\n  let N = 0;\n  for (let i = 0; i < w; i++) {\n    for (let j = 0; j < h; j++) {\n      if (imgArray[4 * (i + w * j) + 3] !== 0) {\n        SX += i;\n        SY += j;\n        N += 1;\n      }\n    }\n  }\n  const Cx = SX / N;\n  const Cy = SY / N;\n  //   console.log(`barycenterSurf: (${Cx},${Cy})`);\n  // console.log(`area: ${N}`);\n  return { center: { x: Cx, y: Cy }, area: N };\n}\n\nconst globalBarycenter = (layers: layerSetup[]): Point => {\n  const neLayers = layers.filter(\n    (d) => (d.layer?.path.data.length as number) > 1,\n  ); // non-empty layers\n\n  const totalArea = neLayers\n    .map((d) => d.layer?.area as number)\n    .reduce((acc, curr) => acc + curr, 0);\n\n  const X =\n    neLayers\n      .map((d) => (d.layer?.barycenter.x as number) * (d.layer?.area as number))\n      .reduce((acc, curr) => acc + curr, 0) / totalArea;\n\n  const Y =\n    neLayers\n      .map((d) => (d.layer?.barycenter.y as number) * (d.layer?.area as number))\n      .reduce((acc, curr) => acc + curr, 0) / totalArea;\n\n  return { x: X, y: Y };\n};\n\nconst drawGlobalBarycenter = (layers: layerSetup[], targetLayer: Layer) => {\n  const neLayers = layers.filter(\n    (d) => (d.layer?.path.data.length as number) > 1,\n  ); // non-empty layers\n\n  targetLayer.clear();\n\n  if (neLayers.length > 0) {\n    const C = globalBarycenter(neLayers);\n    targetLayer.barycenter = C;\n    targetLayer.drawBarycenter();\n  }\n};\n\nexport {\n  Point,\n  barycenterBySurface,\n  barycenterByBorder,\n  globalBarycenter,\n  drawGlobalBarycenter,\n};\n","import { Mode } from './uiFunctions';\nimport { Point, distSq } from './mathHelpers';\nimport { barycenterBySurface } from './barycenter';\n\nexport default class ModeDraw implements Mode {\n  ctx: CanvasRenderingContext2D;\n  cnv: HTMLCanvasElement;\n  drawing = false;\n  color = 'lightblue';\n  lastPoint = { x: 0, y: 0 };\n  stickLengthSq = 0.5;\n  actRadiusSq = 60 * 60; // activation radius squared\n  path: Point[];\n  w: number;\n  h: number;\n\n  dragged = (e: PointerEvent): void => {\n    if (this.drawing && e.isPrimary) {\n      const d = distSq(this.lastPoint, { x: e.offsetX, y: e.offsetY });\n      if (d > this.stickLengthSq) {\n        this.lastPoint.x = e.offsetX;\n        this.lastPoint.y = e.offsetY;\n        this.path.push({ x: this.lastPoint.x, y: this.lastPoint.y });\n        this.draw();\n      }\n    }\n  };\n\n  pointedDown = (e: PointerEvent) => {\n    if (e.isPrimary) {\n      const d = distSq(this.lastPoint, { x: e.offsetX, y: e.offsetY });\n      if (d > this.actRadiusSq) {\n        this.path = [];\n        this.clear();\n      }\n      this.drawing = true;\n    }\n  };\n\n  pointedUp = () => {\n    this.drawing = false;\n\n    const iniPt = this.path[0];\n    const endPt = this.path[this.path.length - 1];\n    if (distSq(iniPt, endPt) < this.actRadiusSq) {\n      this.color = 'olive';\n      this.draw();\n      this.deactivate();\n    }\n  };\n\n  clear = () => {\n    this.path = [];\n    this.ctx.clearRect(0, 0, this.cnv.width, this.cnv.width);\n  };\n\n  draw = () => {\n    this.ctx.clearRect(0, 0, this.cnv.width, this.cnv.height);\n    this.ctx.beginPath();\n    this.ctx.moveTo(this.path[0].x, this.path[0].y);\n    for (let i = 1; i < this.path.length; i++) {\n      this.ctx.lineTo(this.path[i].x, this.path[i].y);\n    }\n    this.ctx.strokeStyle = 'black';\n    this.ctx.lineWidth = 2;\n    this.ctx.fillStyle = this.color;\n    this.ctx.fill('evenodd');\n    if (this.color === 'olive') this.ctx.closePath();\n    this.ctx.stroke();\n\n    //   const B = barycenter(path);\n    const B = barycenterBySurface(this.ctx).center;\n\n    this.ctx.beginPath();\n    this.ctx.arc(B.x, B.y, 5, 0, 2 * Math.PI, false);\n    this.ctx.fillStyle = 'red';\n    this.ctx.fill();\n    this.ctx.stroke();\n  };\n\n  constructor(ctx: CanvasRenderingContext2D, path: Point[]) {\n    this.ctx = ctx;\n    this.cnv = ctx.canvas;\n    this.path = path;\n    this.w = this.cnv.width;\n    this.h = this.cnv.height;\n  }\n\n  activate(): void {\n    this.path = [];\n    this.color = 'lightblue';\n    this.cnv.addEventListener('pointermove', this.dragged);\n    this.cnv.addEventListener('pointerdown', this.pointedDown);\n    this.cnv.addEventListener('pointerup', this.pointedUp);\n    this.cnv.addEventListener('pointerout', this.pointedUp);\n  }\n\n  deactivate(): void {\n    this.cnv.removeEventListener('pointermove', this.dragged);\n    this.cnv.removeEventListener('pointerdown', this.pointedDown);\n    this.cnv.removeEventListener('pointerup', this.pointedUp);\n    this.cnv.removeEventListener('pointerout', this.pointedUp);\n  }\n}\n","import ready from 'document-ready';\nimport { Point } from './barycenter';\n// import { Point, barycenterBySurface } from './barycenter';\n// import { ModeConfig } from './uiFunctions';\nimport ModeDraw from './modeDraw-old';\n\ndeclare global {\n  interface Window {\n    path: Point[];\n    barySur: (ctx: CanvasRenderingContext2D) => Point;\n  }\n}\n\nfunction main() {\n  const drawApp = document.getElementById('drawApp') as HTMLDivElement;\n  const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n\n  const ctx = canvas.getContext('2d', {\n    willReadFrequently: true,\n  }) as CanvasRenderingContext2D;\n\n  console.log('width: ', canvas.width);\n  console.log('height: ', canvas.height);\n\n  const path = [] as Point[];\n\n  const mode = new ModeDraw(ctx, path);\n  mode.activate();\n  // window.mode = mode;\n\n  drawApp.addEventListener(\n    'fullscreenchange',\n    function () {\n      if (drawApp !== document.fullscreenElement) {\n        canvas.width = 800;\n        canvas.height = 800;\n      }\n    },\n    false,\n  );\n\n  document.getElementById('appBtn')?.addEventListener('click', () => {\n    const ww = screen.width;\n    const hh = screen.height;\n    canvas.width = Math.max(ww, hh);\n    canvas.height = Math.min(ww, hh);\n    drawApp\n      .requestFullscreen()\n      .then(() => screen.orientation.lock('landscape'))\n      .then(\n        (success) => {\n          console.log(success);\n        },\n        (failure) => {\n          console.log(failure);\n        },\n      )\n      .catch((err: Error) => {\n        alert(\n          `An error occurred while trying to switch into fullscreen mode: ${err.message} (${err.name})`,\n        );\n      });\n  });\n  // window.path = path;\n  // window.barySur = barycenterBySurface;\n  document.getElementById('drawButton')?.addEventListener('click', () => {\n    mode.clear();\n    mode.activate();\n  });\n}\n\nready(main);\n"],"names":["$a4c08666819fb319$exports","callback","document","Error","state","readyState","setTimeout","addEventListener","$aae5c5ac5df842ce$export$1717f45d0ace7417","ptA","ptB","x","y","$ce69b712342be4e9$export$694614eb4b58a2ae","ctx","w","canvas","width","h","height","imgArray","getImageData","data","SX","SY","N","i","j","center","area","$ea581e40972ccb3c$export$2e2bcd8739ae039","drawing","color","lastPoint","stickLengthSq","actRadiusSq","dragged","e","this","isPrimary","offsetX","offsetY","path","push","draw","pointedDown","clear","pointedUp","iniPt","endPt","length","deactivate","clearRect","cnv","beginPath","moveTo","lineTo","strokeStyle","lineWidth","fillStyle","fill","closePath","stroke","B","arc","Math","PI","constructor","activate","removeEventListener","$parcel$interopDefault","drawApp","getElementById","getContext","willReadFrequently","console","log","mode","fullscreenElement","ww","screen","hh","max","min","requestFullscreen","then","orientation","lock","success","failure","catch","err","alert","message","name"],"version":3,"file":"index.8d74658b.js.map"}